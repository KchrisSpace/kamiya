# 后台管理员功能设计与实现文档

## 5.8 后台管理员模块的设计与实现

该模块为系统管理员提供全面的后台管理功能，包括数据统计、商品管理、订单管理、用户管理、评论管理、反馈管理和系统设置等核心功能，帮助管理员高效地运营和管理花卉商城系统。

## 5.8.1 数据仪表盘模块

### （1）功能描述

管理员登录后台后，首先进入数据仪表盘页面。该页面提供全面的数据概览，包括总销售额、订单总数、商品总数、用户总数等关键指标，以及销售趋势图表、订单状态分布、热门商品排行、库存预警和最近订单列表。管理员可以通过日期范围选择器筛选数据，并实时刷新统计数据。

### （2）实现方案

页面加载时，前端通过 `axios.get` 并行请求获取订单、商品、用户等数据。然后通过 `computed` 属性计算各项统计数据，包括总销售额（累加所有订单金额）、订单总数、商品总数、用户总数等。销售趋势图使用 ECharts 库，根据选择的周期类型（日/周/月）对订单数据进行分组统计。订单状态分布通过饼图展示各状态订单的数量占比。热门商品通过统计订单中每个商品的销量，取前 10 名展示。库存预警筛选出库存小于等于 10 的商品。最近订单显示最新的 10 条订单记录。

数据仪表盘的流程如图 5-11 所示。

```
管理员进入仪表盘页面
    ↓
并行请求获取数据 (GET /normal_orders, /products_list, /users)
    ↓
计算统计数据（销售额、订单数、商品数、用户数）
    ↓
处理销售趋势数据（按日/周/月分组）
    ↓
统计订单状态分布
    ↓
计算热门商品排行（按销量）
    ↓
筛选库存预警商品（库存 <= 10）
    ↓
获取最近订单（按时间倒序，取前10条）
    ↓
渲染统计卡片和图表
```

**图 5-11 数据仪表盘流程图**

针对数据仪表盘接口，请求参数是日期范围（可选），返回系统的参数是各类统计数据。数据仪表盘接口表如表 5-11 所示。

**表 5-11 数据仪表盘接口表**

| 接口名称 | 数据仪表盘接口                                                                |
| -------- | ----------------------------------------------------------------------------- |
| 接口描述 | 获取仪表盘所需的各类统计数据                                                  |
| URL      | `{{baseurl}}/normal_orders`、`{{baseurl}}/products_list`、`{{baseurl}}/users` |
| method   | GET                                                                           |
| 请求参数 | 无（前端筛选）                                                                |
| 返回参数 | orders（订单列表）、products（商品列表）、users（用户列表）                   |

数据仪表盘核心代码如代码 5-11 所示。

**代码 5-11 数据仪表盘实现代码**

```javascript
// src/views/admin/dashboard/dashboard.vue
import { ref, computed, onMounted } from "vue";
import axios from "axios";

const orders = ref([]);
const products = ref([]);
const users = ref([]);
const allOrders = ref([]);
const loading = ref(false);

// 计算总销售额
const totalSales = computed(() => {
  return orders.value.reduce((sum, order) => {
    return sum + (parseFloat(order.total_price) || 0);
  }, 0);
});

// 计算订单总数
const totalOrders = computed(() => orders.value.length);

// 计算商品总数
const totalProducts = computed(() => products.value.length);

// 计算用户总数（排除管理员）
const totalUsers = computed(
  () => users.value.filter((u) => u.role === "user").length
);

// 销售趋势图表数据
const salesChartData = computed(() => {
  if (!allOrders.value.length) return { dates: [], values: [] };

  const grouped = {};
  allOrders.value.forEach((order) => {
    const date = new Date(order.created_at);
    let key;

    if (salesChartType.value === "day") {
      key = date.toLocaleDateString("zh-CN");
    } else if (salesChartType.value === "week") {
      const weekStart = new Date(date);
      weekStart.setDate(date.getDate() - date.getDay());
      key = `第${Math.ceil((weekStart.getMonth() + 1) / 4)}周`;
    } else {
      const month = String(date.getMonth() + 1).padStart(2, "0");
      key = `${date.getFullYear()}-${month}`;
    }

    if (!grouped[key]) {
      grouped[key] = 0;
    }
    grouped[key] += parseFloat(order.total_price) || 0;
  });

  const dates = Object.keys(grouped).sort();
  const values = dates.map((key) => grouped[key]);

  return { dates, values };
});

// 订单状态分布数据
const orderStatusData = computed(() => {
  const statusCount = {};
  allOrders.value.forEach((order) => {
    const status = order.status || "未知";
    statusCount[status] = (statusCount[status] || 0) + 1;
  });
  return statusCount;
});

// 热门商品（按销量排序）
const hotProducts = computed(() => {
  const productSales = {};
  allOrders.value.forEach((order) => {
    if (order.items && Array.isArray(order.items)) {
      order.items.forEach((item) => {
        const productId = item.product_id;
        if (!productSales[productId]) {
          productSales[productId] = {
            product_id: productId,
            name: item.product_name || `商品 ${productId}`,
            sales: 0,
            revenue: 0,
          };
        }
        productSales[productId].sales += item.quantity || 0;
        productSales[productId].revenue +=
          (item.quantity || 0) * (item.single_price || 0);
      });
    }
  });

  return Object.values(productSales)
    .sort((a, b) => b.sales - a.sales)
    .slice(0, 10)
    .map((item) => {
      const product = products.value.find((p) => p.id === item.product_id);
      return {
        ...item,
        image: product?.images || "",
        name: product?.title || item.name,
      };
    });
});

// 库存预警商品
const lowStockProducts = computed(() => {
  return products.value.filter((p) => (p.stock || 0) <= 10).slice(0, 10);
});

// 最近订单
const recentOrders = computed(() => {
  return allOrders.value
    .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
    .slice(0, 10);
});

// 获取数据
const fetchData = async () => {
  loading.value = true;
  try {
    const [ordersRes, productsRes, usersRes] = await Promise.all([
      axios.get("http://localhost:3001/normal_orders"),
      axios.get("http://localhost:3001/products_list"),
      axios.get("http://localhost:3001/users"),
    ]);

    allOrders.value = ordersRes.data;
    products.value = productsRes.data;
    users.value = usersRes.data;

    // 根据日期范围筛选订单
    if (dateRange.value && dateRange.value.length === 2) {
      const [startDate, endDate] = dateRange.value;
      orders.value = allOrders.value.filter((order) => {
        const orderDate = order.created_at?.split("T")[0];
        return orderDate >= startDate && orderDate <= endDate;
      });
    } else {
      orders.value = allOrders.value;
    }
  } catch (error) {
    console.error("获取数据失败:", error);
    ElMessage.error("获取数据失败");
  } finally {
    loading.value = false;
  }
};

onMounted(() => {
  fetchData();
});
```

---

## 5.8.2 商品管理模块

### （1）功能描述

管理员可以在商品管理页面查看所有商品，支持按商品 ID、商品名称、商品分类等条件筛选。管理员可以对商品进行添加、编辑、删除、上架/下架等操作。商品列表显示商品的基本信息，包括 ID、名称、分类、价格、库存、销量、状态等。支持分页显示，每页可显示 10、20、50、100 条记录。

### （2）实现方案

页面加载时，通过 `axios.get` 获取所有商品数据。筛选功能在前端实现，通过 `computed` 属性对商品列表进行过滤。添加商品时，管理员填写商品表单（名称、价格、库存、描述、图片、分类等），支持设置原价和折扣，系统自动计算当前价格。编辑商品时，加载商品现有数据到表单，管理员修改后提交更新。删除商品时，弹出确认框，确认后通过 `axios.delete` 删除商品。上架/下架操作通过 `axios.put` 更新商品的 `status` 字段（"1"表示上架，"0"表示下架）。

商品管理的流程如图 5-12 所示。

```
管理员进入商品管理页面
    ↓
获取商品列表 (GET /products_list)
    ↓
显示商品列表（支持筛选和分页）
    ↓
添加/编辑/删除/上架下架商品
    ↓
提交数据 (POST/PUT/DELETE /products_list)
    ↓
更新成功，刷新列表
```

**图 5-12 商品管理流程图**

针对商品管理接口，请求参数是商品信息，返回系统的参数是商品数据。商品管理接口表如表 5-12 所示。

**表 5-12 商品管理接口表**

| 接口名称 | 商品管理接口                                                           |
| -------- | ---------------------------------------------------------------------- |
| 接口描述 | 管理员对商品进行增删改查和状态管理                                     |
| URL      | `{{baseurl}}/products_list`                                            |
| method   | GET（查询）、POST（添加）、PUT（更新）、DELETE（删除）                 |
| 请求参数 | id、title、price_info、stock、description、category、status、images... |
| 返回参数 | product：商品数据                                                      |

商品管理核心代码如代码 5-12 所示。

**代码 5-12 商品管理实现代码**

```javascript
// src/views/admin/products/products.vue
import { ref, reactive, computed, onMounted } from "vue";
import { ElMessage, ElMessageBox } from "element-plus";
import axios from "axios";
import { useProductsStore } from "../../../data_stores/products";

const productsStore = useProductsStore();
const allProducts = ref([]);
const currentPage = ref(1);
const pageSize = ref(10);
const loading = ref(false);

const filterForm = reactive({
  id: "",
  name: "",
  category: "",
});

// 筛选后的商品列表
const filteredProducts = computed(() => {
  let result = [...allProducts.value];

  if (filterForm.id) {
    result = result.filter((p) => p.id?.includes(filterForm.id));
  }

  if (filterForm.name) {
    result = result.filter((p) =>
      p.title?.toLowerCase().includes(filterForm.name.toLowerCase())
    );
  }

  if (filterForm.category) {
    result = result.filter((p) => p.main_category === filterForm.category);
  }

  return result;
});

// 分页后的商品列表
const paginatedProducts = computed(() => {
  const start = (currentPage.value - 1) * pageSize.value;
  const end = start + pageSize.value;
  return filteredProducts.value.slice(start, end);
});

// 获取商品列表
const fetchProducts = async () => {
  loading.value = true;
  try {
    await productsStore.fetchProducts();
    allProducts.value = productsStore.products;
  } catch (error) {
    console.error("获取商品失败:", error);
    ElMessage.error("获取商品失败");
  } finally {
    loading.value = false;
  }
};

// 删除商品
const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm("确定要删除该商品吗？", "提示", {
      type: "warning",
    });

    await axios.delete(`http://localhost:3001/products_list/${row.id}`);
    ElMessage.success("删除成功");
    await fetchProducts();
  } catch (error) {
    if (error !== "cancel") {
      console.error("删除失败:", error);
      ElMessage.error("删除失败");
    }
  }
};

// 上架/下架商品
const handleStatus = async (row) => {
  try {
    const newStatus = row.status === "1" ? "0" : "1";
    await axios.put(`http://localhost:3001/products_list/${row.id}`, {
      ...row,
      status: newStatus,
      updated_at: new Date().toISOString(),
    });

    ElMessage.success(newStatus === "1" ? "商品已上架" : "商品已下架");
    await fetchProducts();
  } catch (error) {
    console.error("操作失败:", error);
    ElMessage.error("操作失败");
  }
};

onMounted(() => {
  fetchProducts();
});
```

---

## 5.8.3 订单管理模块

### （1）功能描述

管理员可以在订单管理页面查看所有用户的订单，支持按订单号、订单状态、下单时间等条件筛选。订单列表显示订单的基本信息，包括订单号、用户 ID、下单时间、订单金额、订单状态、客户信息等。管理员可以查看订单详情，对于"待商家确认"状态的订单可以拒绝接单，对于"预备出餐中"状态的订单可以确认出餐，将订单状态更新为"已出餐"。

### （2）实现方案

页面加载时，通过 `axios.get` 获取所有订单数据。订单号通过格式化订单 ID 生成（格式：ORDER + 6 位数字）。筛选功能在前端实现，支持按订单号、状态、日期范围筛选。查看订单详情时，弹窗显示订单的完整信息，包括商品列表、总价、取餐信息、订单状态等。确认出餐时，通过 `axios.patch` 更新订单状态为"已出餐"，同时记录 `shipped_time`。拒绝接单时，更新订单状态为"已取消"。

订单管理的流程如图 5-13 所示。

```
管理员进入订单管理页面
    ↓
获取订单列表 (GET /normal_orders)
    ↓
显示订单列表（支持筛选和分页）
    ↓
查看订单详情/确认出餐/拒绝接单
    ↓
更新订单状态 (PATCH /normal_orders/:id)
    ↓
更新成功，刷新列表
```

**图 5-13 订单管理流程图**

针对订单管理接口，请求参数是订单 ID 和更新数据，返回系统的参数是更新后的订单数据。订单管理接口表如表 5-13 所示。

**表 5-13 订单管理接口表**

| 接口名称 | 订单管理接口                         |
| -------- | ------------------------------------ |
| 接口描述 | 管理员查看和管理订单                 |
| URL      | `{{baseurl}}/normal_orders`          |
| method   | GET（查询）、PATCH（更新）           |
| 请求参数 | id、status、shipped_time、updated_at |
| 返回参数 | order：订单数据                      |

订单管理核心代码如代码 5-13 所示。

**代码 5-13 订单管理实现代码**

```javascript
// src/views/admin/orders/orders.vue
import { ref, reactive, onMounted, computed } from "vue";
import { ElMessage, ElMessageBox } from "element-plus";
import axios from "axios";

const loading = ref(false);
const allOrders = ref([]);
const currentPage = ref(1);
const pageSize = ref(10);
const dialogVisible = ref(false);
const currentOrder = ref(null);

const filterForm = reactive({
  orderNo: "",
  status: "",
  dateRange: [],
});

// 格式化订单数据
const formatOrder = (order) => {
  return {
    id: order.id,
    orderNo: `ORDER${String(order.id).padStart(6, "0")}`,
    userId: order.user_id || "未知",
    createTime: order.created_at
      ? new Date(order.created_at).toLocaleString("zh-CN")
      : "",
    totalAmount: order.total_price || "0.00",
    status: order.status || "待商家确认",
    customer: {
      name: order.consignee || "",
      phone: order.phone || "",
    },
    ...order,
  };
};

// 筛选后的订单列表
const filteredOrders = computed(() => {
  let result = allOrders.value.map(formatOrder);

  if (filterForm.orderNo) {
    result = result.filter((order) =>
      order.orderNo.toLowerCase().includes(filterForm.orderNo.toLowerCase())
    );
  }

  if (filterForm.status) {
    result = result.filter((order) => order.status === filterForm.status);
  }

  if (filterForm.dateRange && filterForm.dateRange.length === 2) {
    const [startDate, endDate] = filterForm.dateRange;
    result = result.filter((order) => {
      const orderDate = order.created_at?.split("T")[0];
      return orderDate >= startDate && orderDate <= endDate;
    });
  }

  return result;
});

// 分页后的订单列表
const orders = computed(() => {
  const start = (currentPage.value - 1) * pageSize.value;
  const end = start + pageSize.value;
  return filteredOrders.value.slice(start, end);
});

// 获取订单列表
const fetchOrders = async () => {
  loading.value = true;
  try {
    const response = await axios.get("http://localhost:3001/normal_orders");
    allOrders.value = response.data;
  } catch (error) {
    console.error("获取订单失败:", error);
    ElMessage.error("获取订单失败");
  } finally {
    loading.value = false;
  }
};

// 确认出餐
const handleConfirmDelivery = async (row) => {
  try {
    await ElMessageBox.confirm("确认该订单已出餐？", "提示", {
      type: "warning",
    });

    await axios.patch(`http://localhost:3001/normal_orders/${row.id}`, {
      status: "已出餐",
      shipped_time: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("订单状态已更新为已出餐");
    await fetchOrders();
  } catch (error) {
    if (error !== "cancel") {
      console.error("更新订单状态失败:", error);
      ElMessage.error("更新失败，请稍后重试");
    }
  }
};

// 拒绝接单
const handleReject = async (row) => {
  try {
    await ElMessageBox.confirm("确定要拒绝该订单吗？", "提示", {
      type: "warning",
    });

    await axios.patch(`http://localhost:3001/normal_orders/${row.id}`, {
      status: "已取消",
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("订单已拒绝");
    await fetchOrders();
  } catch (error) {
    if (error !== "cancel") {
      console.error("拒绝订单失败:", error);
      ElMessage.error("操作失败，请稍后重试");
    }
  }
};

onMounted(() => {
  fetchOrders();
});
```

---

## 5.8.4 用户管理模块

### （1）功能描述

管理员可以在用户管理页面查看所有用户信息，包括用户 ID、登录账号、昵称、邮箱、手机号、角色、状态等。页面顶部显示用户统计信息，包括用户总数、管理员数、普通用户数、已禁用用户数。管理员可以对用户进行添加、编辑、删除、启用/禁用等操作。支持按登录账号、用户角色、账户状态等条件筛选。

### （2）实现方案

页面加载时，通过 `axios.get` 获取所有用户数据，并计算统计信息。添加用户时，系统自动生成用户 ID（格式：user + 6 位时间戳 + 随机后缀），管理员填写用户表单后提交。编辑用户时，加载用户现有数据到表单，管理员修改后提交更新。删除用户时，弹出确认框，确认后通过 `axios.delete` 删除用户。启用/禁用操作通过 `axios.put` 更新用户的 `account_status` 字段。筛选功能在前端实现，通过 `computed` 属性对用户列表进行过滤。

用户管理的流程如图 5-14 所示。

```
管理员进入用户管理页面
    ↓
获取用户列表 (GET /users)
    ↓
计算统计信息（总数、管理员数、普通用户数、禁用数）
    ↓
显示用户列表（支持筛选和分页）
    ↓
添加/编辑/删除/启用禁用用户
    ↓
提交数据 (POST/PUT/DELETE /users)
    ↓
更新成功，刷新列表
```

**图 5-14 用户管理流程图**

针对用户管理接口，请求参数是用户信息，返回系统的参数是用户数据。用户管理接口表如表 5-14 所示。

**表 5-14 用户管理接口表**

| 接口名称 | 用户管理接口                                                             |
| -------- | ------------------------------------------------------------------------ |
| 接口描述 | 管理员对用户进行增删改查和状态管理                                       |
| URL      | `{{baseurl}}/users`                                                      |
| method   | GET（查询）、POST（添加）、PUT（更新）、DELETE（删除）                   |
| 请求参数 | id、username、password、role、email、phone、user_info、account_status... |
| 返回参数 | user：用户数据                                                           |

用户管理核心代码如代码 5-14 所示。

**代码 5-14 用户管理实现代码**

```javascript
// src/views/admin/users/users.vue
import { ref, reactive, computed, onMounted } from "vue";
import { ElMessage, ElMessageBox } from "element-plus";
import axios from "axios";

const loading = ref(false);
const allUsers = ref([]);
const currentPage = ref(1);
const pageSize = ref(10);

const filterForm = reactive({
  username: "",
  role: "",
  status: "",
});

// 统计信息
const stats = computed(() => {
  return {
    total: allUsers.value.length,
    admins: allUsers.value.filter((u) => u.role === "admin").length,
    users: allUsers.value.filter((u) => u.role === "user").length,
    disabled: allUsers.value.filter(
      (u) => u.account_status === "inactive" || u.account_status === "banned"
    ).length,
  };
});

// 筛选后的用户列表
const filteredUsers = computed(() => {
  let result = [...allUsers.value];

  if (filterForm.username) {
    result = result.filter((u) =>
      u.username?.toLowerCase().includes(filterForm.username.toLowerCase())
    );
  }

  if (filterForm.role) {
    result = result.filter((u) => u.role === filterForm.role);
  }

  if (filterForm.status) {
    if (filterForm.status === "1") {
      result = result.filter(
        (u) => u.account_status !== "inactive" && u.account_status !== "banned"
      );
    } else {
      result = result.filter(
        (u) => u.account_status === "inactive" || u.account_status === "banned"
      );
    }
  }

  return result;
});

// 分页后的用户列表
const users = computed(() => {
  const start = (currentPage.value - 1) * pageSize.value;
  const end = start + pageSize.value;
  return filteredUsers.value.slice(start, end);
});

// 生成用户ID
const generateUserId = () => {
  const timestamp = Date.now().toString();
  const randomSuffix = Math.random().toString(36).substr(2, 3);
  let userId = `user${timestamp.slice(-6)}${randomSuffix}`;

  // 检查ID是否已存在
  while (allUsers.value.some((u) => u.id === userId)) {
    const newTimestamp = Date.now().toString();
    const newRandomSuffix = Math.random().toString(36).substr(2, 3);
    userId = `user${newTimestamp.slice(-6)}${newRandomSuffix}`;
  }

  return userId;
};

// 获取用户列表
const fetchUsers = async () => {
  loading.value = true;
  try {
    const response = await axios.get("http://localhost:3001/users");
    allUsers.value = response.data;
  } catch (error) {
    console.error("获取用户失败:", error);
    ElMessage.error("获取用户失败");
  } finally {
    loading.value = false;
  }
};

// 删除用户
const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm("确定要删除该用户吗？", "提示", {
      type: "warning",
    });

    await axios.delete(`http://localhost:3001/users/${row.id}`);
    ElMessage.success("删除成功");
    await fetchUsers();
  } catch (error) {
    if (error !== "cancel") {
      console.error("删除失败:", error);
      ElMessage.error("删除失败");
    }
  }
};

onMounted(() => {
  fetchUsers();
});
```

---

## 5.8.5 评论管理模块

### （1）功能描述

管理员可以在评论管理页面查看所有用户对商品的评价，支持按商品名称、用户 ID、评分、状态等条件筛选。评论列表显示评论的基本信息，包括评论 ID、商品信息、用户信息、评分、评论内容、标签、图片、商家回复等。管理员可以设置评论的可见性（可见/不可见），可以回复评论，也可以删除评论。

### （2）实现方案

页面加载时，通过 `axios.get` 获取所有评论数据和商品数据。筛选功能在前端实现，通过 `computed` 属性对评论列表进行过滤。设置可见性时，通过 `axios.patch` 更新评论的 `is_visible` 字段（true 表示可见，false 表示不可见）。回复评论时，弹出回复对话框，管理员输入回复内容后，通过 `axios.patch` 更新评论的 `reply` 和 `reply_time` 字段。删除评论时，弹出确认框，确认后通过 `axios.delete` 删除评论。

评论管理的流程如图 5-15 所示。

```
管理员进入评论管理页面
    ↓
获取评论列表和商品列表 (GET /product_comments, /products_list)
    ↓
显示评论列表（支持筛选和分页）
    ↓
设置可见性/回复评论/删除评论
    ↓
更新评论数据 (PATCH/DELETE /product_comments/:id)
    ↓
更新成功，刷新列表
```

**图 5-15 评论管理流程图**

针对评论管理接口，请求参数是评论 ID 和更新数据，返回系统的参数是更新后的评论数据。评论管理接口表如表 5-15 所示。

**表 5-15 评论管理接口表**

| 接口名称 | 评论管理接口                                  |
| -------- | --------------------------------------------- |
| 接口描述 | 管理员查看和管理商品评论                      |
| URL      | `{{baseurl}}/product_comments`                |
| method   | GET（查询）、PATCH（更新）、DELETE（删除）    |
| 请求参数 | id、is_visible、reply、reply_time、updated_at |
| 返回参数 | comment：评论数据                             |

评论管理核心代码如代码 5-15 所示。

**代码 5-15 评论管理实现代码**

```javascript
// src/views/admin/comments/comments.vue
import { ref, reactive, computed, onMounted } from "vue";
import { ElMessage, ElMessageBox } from "element-plus";
import axios from "axios";
import { useProductsStore } from "../../../data_stores/products";

const productsStore = useProductsStore();
const loading = ref(false);
const allComments = ref([]);
const currentPage = ref(1);
const pageSize = ref(10);
const replyDialogVisible = ref(false);
const currentComment = ref(null);
const replying = ref(false);

const filterForm = reactive({
  productName: "",
  userId: "",
  rating: "",
  status: "",
});

const replyForm = reactive({
  reply: "",
});

// 筛选后的评论列表
const filteredComments = computed(() => {
  let result = [...allComments.value];

  // 商品名称过滤
  if (filterForm.productName && filterForm.productName.trim()) {
    const productName = filterForm.productName.trim().toLowerCase();
    result = result.filter((comment) => {
      const product = productsStore.products.find(
        (p) => p.id === comment.product_id
      );
      const name = product?.title || "";
      return name.toLowerCase().includes(productName);
    });
  }

  // 用户ID过滤
  if (filterForm.userId && filterForm.userId.trim()) {
    const userId = filterForm.userId.trim().toLowerCase();
    result = result.filter((comment) =>
      comment.user_id?.toLowerCase().includes(userId)
    );
  }

  // 评分过滤
  if (filterForm.rating) {
    result = result.filter(
      (comment) => comment.rating === Number(filterForm.rating)
    );
  }

  // 状态过滤
  if (filterForm.status === "visible") {
    result = result.filter((comment) => comment.is_visible !== false);
  } else if (filterForm.status === "hidden") {
    result = result.filter((comment) => comment.is_visible === false);
  }

  return result;
});

// 分页后的评论列表
const paginatedComments = computed(() => {
  const start = (currentPage.value - 1) * pageSize.value;
  const end = start + pageSize.value;
  return filteredComments.value.slice(start, end);
});

// 获取评论列表
const fetchComments = async () => {
  loading.value = true;
  try {
    const [commentsRes] = await Promise.all([
      axios.get("http://localhost:3001/product_comments"),
      productsStore.fetchProducts(),
    ]);

    allComments.value = commentsRes.data;
  } catch (error) {
    console.error("获取评论失败:", error);
    ElMessage.error("获取评论失败");
  } finally {
    loading.value = false;
  }
};

// 设置可见性
const handleToggleVisibility = async (row) => {
  try {
    const newVisibility = row.is_visible === false ? true : false;
    await axios.patch(`http://localhost:3001/product_comments/${row.id}`, {
      is_visible: newVisibility,
      updated_at: new Date().toISOString(),
    });

    ElMessage.success(newVisibility ? "评论已设为可见" : "评论已设为不可见");
    await fetchComments();
  } catch (error) {
    console.error("操作失败:", error);
    ElMessage.error("操作失败，请稍后重试");
  }
};

// 回复评论
const handleReply = (row) => {
  currentComment.value = row;
  replyForm.reply = row.reply || "";
  replyDialogVisible.value = true;
};

const handleSubmitReply = async () => {
  if (!replyForm.reply.trim()) {
    ElMessage.warning("请输入回复内容");
    return;
  }

  replying.value = true;
  try {
    await axios.patch(
      `http://localhost:3001/product_comments/${currentComment.value.id}`,
      {
        reply: replyForm.reply.trim(),
        reply_time: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      }
    );

    ElMessage.success("回复成功");
    replyDialogVisible.value = false;
    await fetchComments();
  } catch (error) {
    console.error("回复失败:", error);
    ElMessage.error("回复失败，请稍后重试");
  } finally {
    replying.value = false;
  }
};

// 删除评论
const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm("确定要删除该评论吗？", "提示", {
      type: "warning",
    });

    await axios.delete(`http://localhost:3001/product_comments/${row.id}`);
    ElMessage.success("删除成功");
    await fetchComments();
  } catch (error) {
    if (error !== "cancel") {
      console.error("删除失败:", error);
      ElMessage.error("删除失败");
    }
  }
};

onMounted(() => {
  fetchComments();
});
```

---

## 5.8.6 反馈管理模块

### （1）功能描述

管理员可以在反馈管理页面查看所有用户提交的反馈信息，支持按用户 ID、姓名、邮箱、电话、处理状态等条件筛选。反馈列表显示反馈的基本信息，包括反馈 ID、用户 ID、姓名、邮箱、电话、反馈内容、处理状态、提交时间等。管理员可以查看反馈详情，可以标记反馈为"已处理"或"未处理"，也可以删除反馈。

### （2）实现方案

页面加载时，通过 `axios.get` 获取所有反馈数据。筛选功能在前端实现，通过 `computed` 属性对反馈列表进行过滤。查看反馈详情时，弹窗显示反馈的完整信息。标记处理状态时，通过 `axios.patch` 更新反馈的 `status` 字段（"processed"表示已处理，"pending"表示未处理）。删除反馈时，弹出确认框，确认后通过 `axios.delete` 删除反馈。

反馈管理的流程如图 5-16 所示。

```
管理员进入反馈管理页面
    ↓
获取反馈列表 (GET /feedback)
    ↓
显示反馈列表（支持筛选和分页）
    ↓
查看详情/标记处理状态/删除反馈
    ↓
更新反馈数据 (PATCH/DELETE /feedback/:id)
    ↓
更新成功，刷新列表
```

**图 5-16 反馈管理流程图**

针对反馈管理接口，请求参数是反馈 ID 和更新数据，返回系统的参数是更新后的反馈数据。反馈管理接口表如表 5-16 所示。

**表 5-16 反馈管理接口表**

| 接口名称 | 反馈管理接口                               |
| -------- | ------------------------------------------ |
| 接口描述 | 管理员查看和管理用户反馈                   |
| URL      | `{{baseurl}}/feedback`                     |
| method   | GET（查询）、PATCH（更新）、DELETE（删除） |
| 请求参数 | id、status、updated_at                     |
| 返回参数 | feedback：反馈数据                         |

反馈管理核心代码如代码 5-16 所示。

**代码 5-16 反馈管理实现代码**

```javascript
// src/views/admin/feedback/feedback.vue
import { ref, reactive, computed, onMounted } from "vue";
import { ElMessage, ElMessageBox } from "element-plus";
import axios from "axios";

const loading = ref(false);
const allFeedback = ref([]);
const currentPage = ref(1);
const pageSize = ref(10);
const detailDialogVisible = ref(false);
const currentFeedback = ref(null);

const filterForm = reactive({
  userId: "",
  name: "",
  email: "",
  phone: "",
  status: "",
});

// 筛选后的反馈列表
const filteredFeedback = computed(() => {
  let result = [...allFeedback.value];

  if (filterForm.userId) {
    result = result.filter((f) =>
      f.user_id?.toLowerCase().includes(filterForm.userId.toLowerCase())
    );
  }

  if (filterForm.name) {
    result = result.filter((f) =>
      f.name?.toLowerCase().includes(filterForm.name.toLowerCase())
    );
  }

  if (filterForm.email) {
    result = result.filter((f) =>
      f.email?.toLowerCase().includes(filterForm.email.toLowerCase())
    );
  }

  if (filterForm.phone) {
    result = result.filter((f) => f.phone?.includes(filterForm.phone));
  }

  if (filterForm.status) {
    result = result.filter((f) => f.status === filterForm.status);
  }

  return result;
});

// 分页后的反馈列表
const paginatedFeedback = computed(() => {
  const start = (currentPage.value - 1) * pageSize.value;
  const end = start + pageSize.value;
  return filteredFeedback.value.slice(start, end);
});

// 获取反馈列表
const fetchFeedback = async () => {
  loading.value = true;
  try {
    const response = await axios.get("http://localhost:3001/feedback");
    allFeedback.value = response.data;
  } catch (error) {
    console.error("获取反馈失败:", error);
    ElMessage.error("获取反馈失败");
  } finally {
    loading.value = false;
  }
};

// 查看详情
const handleViewDetail = (row) => {
  currentFeedback.value = row;
  detailDialogVisible.value = true;
};

// 切换处理状态
const handleToggleStatus = async (row) => {
  try {
    const newStatus = row.status === "processed" ? "pending" : "processed";
    await axios.patch(`http://localhost:3001/feedback/${row.id}`, {
      status: newStatus,
      updated_at: new Date().toISOString(),
    });

    ElMessage.success(
      newStatus === "processed" ? "已标记为已处理" : "已标记为未处理"
    );
    await fetchFeedback();
  } catch (error) {
    console.error("操作失败:", error);
    ElMessage.error("操作失败，请稍后重试");
  }
};

// 删除反馈
const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm("确定要删除该反馈吗？", "提示", {
      type: "warning",
    });

    await axios.delete(`http://localhost:3001/feedback/${row.id}`);
    ElMessage.success("删除成功");
    await fetchFeedback();
  } catch (error) {
    if (error !== "cancel") {
      console.error("删除失败:", error);
      ElMessage.error("删除失败");
    }
  }
};

onMounted(() => {
  fetchFeedback();
});
```

---

## 5.8.7 系统设置模块

### （1）功能描述

管理员可以在系统设置页面管理系统的各项配置，包括店铺信息（店铺名称、Logo、描述、联系方式、地址）、营业设置（营业时间、取餐时间段）、通知设置（订单通知、系统通知）、数据管理（数据备份、数据恢复）、系统维护（系统日志、缓存清理）等。

### （2）实现方案

系统设置页面采用左侧分类菜单、右侧内容区域的布局。管理员选择不同的设置分类，右侧显示对应的设置表单。店铺信息设置包括店铺名称、Logo 上传、店铺描述、联系电话、联系邮箱、店铺地址等字段，管理员填写后点击"保存设置"按钮，通过 `axios.put` 更新系统配置。营业设置包括营业开始时间、营业结束时间、取餐时间段配置等。通知设置包括订单通知开关、系统通知开关等。数据管理包括数据备份和恢复功能。系统维护包括查看系统日志、清理缓存等功能。

系统设置的流程如图 5-17 所示。

```
管理员进入系统设置页面
    ↓
选择设置分类（店铺信息/营业设置/通知设置/数据管理/系统维护）
    ↓
显示对应的设置表单
    ↓
管理员修改设置
    ↓
点击"保存设置"按钮
    ↓
提交数据 (PUT /custom)
    ↓
保存成功，显示提示信息
```

**图 5-17 系统设置流程图**

针对系统设置接口，请求参数是配置数据，返回系统的参数是更新后的配置数据。系统设置接口表如表 5-17 所示。

**表 5-17 系统设置接口表**

| 接口名称 | 系统设置接口                                                                        |
| -------- | ----------------------------------------------------------------------------------- |
| 接口描述 | 管理员管理系统配置                                                                  |
| URL      | `{{baseurl}}/custom`                                                                |
| method   | GET（查询）、PUT（更新）                                                            |
| 请求参数 | shop_info、business_settings、notification_settings、data_settings、system_settings |
| 返回参数 | config：配置数据                                                                    |

系统设置核心代码如代码 5-17 所示。

**代码 5-17 系统设置实现代码**

```javascript
// src/views/admin/settings/settings.vue
import { ref, reactive, onMounted } from "vue";
import { ElMessage } from "element-plus";
import axios from "axios";

const activeCategory = ref("shop");
const saving = ref(false);

const shopForm = reactive({
  shopName: "",
  logo: "",
  description: "",
  phone: "",
  email: "",
  address: "",
});

const businessForm = reactive({
  openTime: "09:00",
  closeTime: "21:00",
  timeSlots: [
    { label: "09:00-12:00", value: "09:00-12:00", enabled: true },
    { label: "12:00-15:00", value: "12:00-15:00", enabled: true },
    { label: "15:00-18:00", value: "15:00-18:00", enabled: true },
    { label: "18:00-21:00", value: "18:00-21:00", enabled: true },
  ],
});

const notificationForm = reactive({
  orderNotification: true,
  systemNotification: true,
});

// 获取系统配置
const fetchSettings = async () => {
  try {
    const response = await axios.get("http://localhost:3001/custom");
    const config = response.data[0] || {};

    if (config.shop_info) {
      Object.assign(shopForm, config.shop_info);
    }

    if (config.business_settings) {
      Object.assign(businessForm, config.business_settings);
    }

    if (config.notification_settings) {
      Object.assign(notificationForm, config.notification_settings);
    }
  } catch (error) {
    console.error("获取设置失败:", error);
  }
};

// 保存店铺信息
const handleShopSubmit = async () => {
  saving.value = true;
  try {
    const response = await axios.get("http://localhost:3001/custom");
    const existingConfig = response.data[0] || { id: "config1" };

    await axios.put(`http://localhost:3001/custom/${existingConfig.id}`, {
      ...existingConfig,
      shop_info: shopForm,
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("店铺信息保存成功");
  } catch (error) {
    console.error("保存失败:", error);
    ElMessage.error("保存失败，请稍后重试");
  } finally {
    saving.value = false;
  }
};

// 保存营业设置
const handleBusinessSubmit = async () => {
  saving.value = true;
  try {
    const response = await axios.get("http://localhost:3001/custom");
    const existingConfig = response.data[0] || { id: "config1" };

    await axios.put(`http://localhost:3001/custom/${existingConfig.id}`, {
      ...existingConfig,
      business_settings: businessForm,
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("营业设置保存成功");
  } catch (error) {
    console.error("保存失败:", error);
    ElMessage.error("保存失败，请稍后重试");
  } finally {
    saving.value = false;
  }
};

// 保存通知设置
const handleNotificationSubmit = async () => {
  saving.value = true;
  try {
    const response = await axios.get("http://localhost:3001/custom");
    const existingConfig = response.data[0] || { id: "config1" };

    await axios.put(`http://localhost:3001/custom/${existingConfig.id}`, {
      ...existingConfig,
      notification_settings: notificationForm,
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("通知设置保存成功");
  } catch (error) {
    console.error("保存失败:", error);
    ElMessage.error("保存失败，请稍后重试");
  } finally {
    saving.value = false;
  }
};

onMounted(() => {
  fetchSettings();
});
```

---

**文档版本**: v1.0  
**最后更新**: 2025-12-28  
**维护人员**: 开发团队
