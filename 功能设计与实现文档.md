# Kamiya 花卉商城功能设计与实现文档

## 5.3.1 商品列表的查询与筛选

### （1）功能描述

用户可以在商品列表页面查看所有商品，并通过多种方式进行筛选查询，包括商品名称搜索、价格区间筛选、商品类别筛选等。系统支持实时搜索和组合筛选，帮助用户快速找到心仪的商品。

### （2）实现方案

首先，前端通过 `axios.get` 请求从 JSON Server 获取所有商品数据。然后根据用户输入的搜索关键词、选择的价格区间和商品类别，在前端进行数据过滤。搜索功能使用防抖（debounce）技术优化性能，避免频繁请求。筛选后的商品列表通过 `computed` 属性实时更新展示。

商品列表查询的流程如图 5-1 所示。

```
用户进入商品列表页面
    ↓
前端请求获取所有商品数据 (GET /products_list)
    ↓
JSON Server 返回商品列表
    ↓
用户输入搜索关键词/选择筛选条件
    ↓
前端进行数据过滤（computed 属性）
    ↓
实时更新商品列表展示
```

**图 5-1 商品列表查询流程图**

针对商品查询功能，请求参数包括搜索关键词、价格区间、商品类别等，返回系统的参数是商品信息列表，比如商品ID、商品名称、价格、库存等。商品查询接口表如表 5-1 所示。

**表 5-1 商品查询接口表**

| 接口名称 | 商品查询接口 |
|---------|------------|
| 接口描述 | 用户进入商品列表时，获取所有商品数据 |
| URL | `{{baseurl}}/products_list` |
| method | GET |
| 请求参数 | 无（前端筛选） |
| 返回参数 | 商品数组：id、title、price_info、stock、category、images、status... |

用户查询商品核心代码如代码 5-1 所示。

**代码 5-1 商品查询实现前端代码**

```javascript
// src/views/store/Store.vue
import { ref, computed, onMounted } from "vue";
import axios from "axios";

const goods = ref([]);
const searchKeyword = ref("");
const priceRange = ref([0, 600]);
const selectedCategory = ref("全部");
const isLoading = ref(false);

// 获取商品数据
const fetchGoods = async () => {
  isLoading.value = true;
  try {
    const response = await axios.get("http://localhost:3001/products_list");
    goods.value = response.data.filter(item => item.status === "1"); // 只显示上架商品
  } catch (error) {
    console.error("获取商品失败:", error);
  } finally {
    isLoading.value = false;
  }
};

// 防抖搜索
const debouncedSearch = debounce(() => {
  handleSearch();
}, 300);

// 筛选后的商品列表
const filteredGoods = computed(() => {
  let result = goods.value;

  // 搜索关键词筛选
  if (searchKeyword.value.trim()) {
    const keyword = searchKeyword.value.toLowerCase();
    result = result.filter(item => 
      item.title.toLowerCase().includes(keyword) ||
      item.description?.toLowerCase().includes(keyword) ||
      item.promotion?.keywords?.some(k => k.toLowerCase().includes(keyword))
    );
  }

  // 价格区间筛选
  result = result.filter(item => {
    const price = parseFloat(item.price_info?.current_price || 0);
    return price >= priceRange.value[0] && price <= priceRange.value[1];
  });

  // 类别筛选
  if (selectedCategory.value !== "全部") {
    result = result.filter(item => item.category === selectedCategory.value);
  }

  return result;
});

onMounted(() => {
  fetchGoods();
});
```

---

## 5.3.2 用户登录

### （1）功能描述

用户可以通过用户ID或手机号配合密码进行登录。系统支持管理员和普通用户两种角色，登录后根据角色自动跳转到相应的页面。登录状态会持久化保存，支持"记住我"功能。

### （2）实现方案

首先，前端接收用户输入的登录标识（用户ID或手机号）和密码。系统判断输入的是用户ID还是手机号（通过正则表达式识别手机号格式）。然后通过 `axios.get` 请求获取所有用户数据，在前端进行匹配验证。验证成功后，根据用户角色（admin/user）将登录信息存储到不同的 localStorage 键中，实现管理员和普通用户同时登录的支持。最后更新 Pinia 用户状态并跳转到相应页面。

用户登录的流程如图 5-2 所示。

```
用户输入登录信息（ID/手机号 + 密码）
    ↓
前端验证格式
    ↓
判断输入类型（ID/手机号/用户名）
    ↓
请求获取用户列表 (GET /users)
    ↓
前端匹配用户信息
    ↓
验证密码
    ↓
根据角色存储登录状态（adminToken/userToken）
    ↓
更新 Pinia 用户状态
    ↓
路由跳转（管理员→后台，普通用户→首页）
```

**图 5-2 用户登录流程图**

针对用户登录接口，请求参数是登录标识和密码，返回系统的参数是登录结果和用户信息。用户登录接口表如表 5-2 所示。

**表 5-2 用户登录接口表**

| 接口名称 | 用户登录接口 |
|---------|------------|
| 接口描述 | 用户通过ID或手机号登录系统 |
| URL | `{{baseurl}}/users` |
| method | GET（前端验证） |
| 请求参数 | identifier（用户ID/手机号）、password |
| 返回参数 | 用户列表，前端进行匹配验证 |

用户登录核心代码如代码 5-2 所示。

**代码 5-2 用户登录实现代码**

```javascript
// src/data_stores/user.js
async function login(identifier, password, remember = false) {
  loading.value = true;
  try {
    // 管理员登录
    if (identifier === "admin" && password === "000000") {
      const adminUser = {
        id: "admin",
        username: "admin",
        role: "admin",
        user_info: {
          nickname: "管理员",
          avatar: "/images/users/avater/user0.png",
        },
      };

      setUserInfo(adminUser);
      localStorage.setItem("adminToken", "admin-token");
      localStorage.setItem("adminUserId", "admin");
      localStorage.setItem("adminUserInfo", JSON.stringify(adminUser));

      if (remember) {
        localStorage.setItem("adminRemember", "true");
      }

      ElMessage.success("登录成功");
      return { success: true, isAdmin: true };
    }

    // 获取用户列表
    const response = await axios.get("http://localhost:3001/users");
    if (!response.data || !Array.isArray(response.data)) {
      throw new Error("用户数据格式错误");
    }

    // 判断输入的是ID还是手机号
    const isPhone = /^1[3-9]\d{9}$/.test(identifier);
    const isUserId = identifier.startsWith("user");

    let user = null;

    if (isPhone) {
      // 通过手机号登录
      user = response.data.find(
        (u) => u.phone === identifier && u.password === password
      );
    } else if (isUserId) {
      // 通过用户ID登录
      user = response.data.find(
        (u) => u.id === identifier && u.password === password
      );
    } else {
      // 通过用户名登录
      user = response.data.find(
        (u) => u.username === identifier && u.password === password
      );
    }

    if (user) {
      // 普通用户登录
      setUserInfo(user);
      localStorage.setItem("userToken", "user-token");
      localStorage.setItem("userId", user.id);
      localStorage.setItem("userInfo", JSON.stringify(user));

      if (remember) {
        localStorage.setItem("userRemember", "true");
      }

      ElMessage.success("登录成功");
      return { success: true, isAdmin: false };
    }

    throw new Error("用户ID/手机号或密码错误");
  } catch (error) {
    console.error("登录失败:", error);
    ElMessage.error(error.message || "登录失败，请稍后重试");
    return { success: false, error: error.message };
  } finally {
    loading.value = false;
  }
}
```

---

## 5.3.3 购物车管理

### （1）功能描述

已登录用户可以将商品添加到购物车，在购物车页面查看已选商品、修改商品数量、删除商品。系统会实时检查商品库存，防止超卖。购物车数据会持久化保存到 localStorage 和数据库。

### （2）实现方案

首先，用户点击"加入购物车"按钮时，前端通过 `axios.get` 获取商品详情，检查商品库存和上架状态。如果库存充足且商品已上架，则通过 `axios.post` 将商品添加到购物车（如果商品已存在则更新数量）。购物车数据同时保存到 Pinia Store 和 localStorage，实现数据持久化。在购物车页面，用户可以修改商品数量，系统会再次检查库存，确保数量不超过库存上限。

购物车管理的流程如图 5-3 所示。

```
用户点击"加入购物车"
    ↓
获取商品详情 (GET /products_list/:id)
    ↓
检查商品状态（是否上架、库存是否充足）
    ↓
检查购物车中是否已存在该商品
    ↓
存在：更新数量（POST /cart/:id）
不存在：添加新商品（POST /cart）
    ↓
更新 Pinia Store 和 localStorage
    ↓
显示成功提示
```

**图 5-3 购物车管理流程图**

针对购物车管理接口，请求参数是商品ID和数量，返回系统的参数是购物车项信息。购物车管理接口表如表 5-3 所示。

**表 5-3 购物车管理接口表**

| 接口名称 | 购物车管理接口 |
|---------|--------------|
| 接口描述 | 用户添加、更新、删除购物车商品 |
| URL | `{{baseurl}}/cart` |
| method | GET（查询）、POST（添加）、PUT（更新）、DELETE（删除） |
| 请求参数 | user_id、product_id、quantity |
| 返回参数 | cartItem：id、user_id、product_id、quantity、created_at |

购物车管理核心代码如代码 5-3 所示。

**代码 5-3 购物车管理实现代码**

```javascript
// src/data_stores/cart.js
const addItem = async (productId, quantity = 1, userId = null) => {
  try {
    const currentUserId = userId || localStorage.getItem("userId");
    if (!currentUserId) {
      throw new Error("用户未登录");
    }

    // 获取商品信息，检查库存
    const productResponse = await axios.get(
      `http://localhost:3001/products_list/${productId}`
    );
    const product = productResponse.data;
    
    if (!product) {
      throw new Error("商品不存在");
    }

    // 检查商品是否上架
    if (product.status !== "1") {
      throw new Error("商品已下架，无法添加到购物车");
    }

    // 检查库存
    const currentStock = product.stock || 0;
    if (currentStock <= 0) {
      throw new Error("商品库存不足，无法添加到购物车");
    }

    // 检查商品是否已经在当前用户的购物车中
    const existingItem = cartItems.value.find(
      (item) => (item.product_id || item.id) === productId && item.user_id === currentUserId
    );

    const newQuantity = existingItem ? existingItem.quantity + quantity : quantity;

    // 检查库存是否足够
    if (newQuantity > currentStock) {
      throw new Error(`库存不足，当前库存为 ${currentStock}，您已选择 ${existingItem ? existingItem.quantity : 0} 件，最多只能再添加 ${currentStock - (existingItem ? existingItem.quantity : 0)} 件`);
    }

    if (existingItem) {
      // 如果商品已存在，更新数量
      await axios.put(`http://localhost:3001/cart/${existingItem.id}`, {
        ...existingItem,
        quantity: newQuantity,
      });
    } else {
      // 如果商品不存在，添加新商品
      const cartItemId = `cart_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      await axios.post("http://localhost:3001/cart", {
        id: cartItemId,
        user_id: currentUserId,
        product_id: productId,
        quantity: newQuantity,
        created_at: new Date().toISOString(),
      });
    }

    // 更新本地状态
    await fetchCartData(currentUserId);
    ElMessage.success("已添加到购物车");
  } catch (error) {
    console.error("添加购物车失败:", error);
    ElMessage.error(error.message || "添加失败，请稍后重试");
    throw error;
  }
};
```

---

## 5.3.4 订单创建

### （1）功能描述

已登录用户可以从购物车创建订单。系统会检查所有商品的库存，确保库存充足后创建订单。订单创建时会保存商品快照信息（商品名称、单价），确保历史订单数据不受商品信息变更影响。订单创建成功后，会扣除相应商品的库存。

### （2）实现方案

首先，用户点击"去结算"按钮，系统获取购物车中的所有商品。然后遍历每个商品，通过 `axios.get` 获取商品详情，检查库存是否充足。如果所有商品库存都充足，则构建订单数据，包括商品快照信息。通过 `axios.post` 创建订单到 `normal_orders` 表。订单创建成功后，遍历订单中的商品，通过 `axios.put` 更新每个商品的库存（减去购买数量）。最后清空购物车并跳转到订单列表页面。

订单创建的流程如图 5-4 所示。

```
用户点击"去结算"
    ↓
获取购物车商品列表
    ↓
遍历商品，检查库存（GET /products_list/:id）
    ↓
所有商品库存充足？
    ↓ 否
显示库存不足提示
    ↓ 是
构建订单数据（包含商品快照）
    ↓
创建订单 (POST /normal_orders)
    ↓
遍历订单商品，扣除库存 (PUT /products_list/:id)
    ↓
清空购物车
    ↓
跳转到订单列表页面
```

**图 5-4 订单创建流程图**

针对订单创建接口，请求参数是订单信息，返回系统的参数是创建的订单数据。订单创建接口表如表 5-4 所示。

**表 5-4 订单创建接口表**

| 接口名称 | 订单创建接口 |
|---------|------------|
| 接口描述 | 用户从购物车创建订单 |
| URL | `{{baseurl}}/normal_orders` |
| method | POST |
| 请求参数 | user_id、items（商品快照）、total_price、consignee、phone、remark、delivery_time、status |
| 返回参数 | order：id、user_id、items、total_price、status、created_at... |

订单创建核心代码如代码 5-4 所示。

**代码 5-4 订单创建实现代码**

```javascript
// src/views/order/components/create-order.vue
const createOrder = async () => {
  try {
    // 验证表单
    if (!orderInfo.value.name || !orderInfo.value.phone) {
      ElMessage.warning("请填写完整的取餐信息");
      return;
    }

    // 检查所有商品的库存
    for (const item of cartStore.cartItems) {
      const productId = item.product_id || item.id;
      const productResponse = await axios.get(
        `http://localhost:3001/products_list/${productId}`
      );
      const product = productResponse.data;

      if (!product) {
        throw new Error(`商品 ${item.product?.title} 不存在`);
      }

      const currentStock = product.stock || 0;
      if (currentStock < item.quantity) {
        throw new Error(`商品 ${product.title} 库存不足，当前库存为 ${currentStock}，您选择了 ${item.quantity} 件`);
      }
    }

    // 构建订单数据
    const orderData = {
      user_id: userStore.userId,
      items: cartStore.cartItems.map(item => ({
        product_id: item.product_id || item.id,
        product_name: item.product?.title || "未知商品",
        quantity: item.quantity,
        single_price: parseFloat(item.product?.price_info?.current_price || 0),
      })),
      total_price: totalPrice.value,
      shipping_fee: 0,
      delivery_time: `${selectedDate.value}T${selectedTime.value}:00Z`,
      consignee: orderInfo.value.name,
      phone: orderInfo.value.phone,
      remark: orderInfo.value.remark || "",
      status: "待商家确认",
      payment_method: "wechat",
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    // 创建订单
    const orderResponse = await axios.post(
      "http://localhost:3001/normal_orders",
      orderData
    );

    // 扣除库存
    for (const item of orderData.items) {
      const productResponse = await axios.get(
        `http://localhost:3001/products_list/${item.product_id}`
      );
      const product = productResponse.data;
      
      await axios.put(`http://localhost:3001/products_list/${item.product_id}`, {
        ...product,
        stock: (product.stock || 0) - item.quantity,
        updated_at: new Date().toISOString(),
      });
    }

    // 清空购物车
    await cartStore.clearCart(userStore.userId);

    ElMessage.success("订单创建成功");
    router.push("/order");
  } catch (error) {
    console.error("创建订单失败:", error);
    ElMessage.error(error.message || "创建订单失败，请稍后重试");
  }
};
```

---

## 5.3.5 订单状态管理

### （1）功能描述

管理员可以在后台管理订单状态，包括确认订单、更新订单状态为"预备出餐中"、"已出餐"等。用户端可以查看订单状态，对于"可取餐"状态的订单，用户可以点击"确认取餐"按钮将订单状态更新为"已完成"。

### （2）实现方案

管理员端：管理员在订单管理页面查看所有订单，点击"确认出餐"按钮时，通过 `axios.patch` 更新订单状态为"已出餐"，同时更新 `shipped_time` 和 `updated_at` 字段。

用户端：用户在订单列表页面查看自己的订单，对于状态为"可取餐"（即"已出餐"）的订单，点击"确认取餐"按钮，通过 `axios.patch` 更新订单状态为"已完成"，同时更新 `completed_time` 和 `updated_at` 字段。

订单状态管理的流程如图 5-5 所示。

```
管理员/用户操作
    ↓
点击状态更新按钮
    ↓
发送更新请求 (PATCH /normal_orders/:id)
    ↓
更新订单状态和相应时间字段
    ↓
更新成功，刷新订单列表
```

**图 5-5 订单状态管理流程图**

针对订单状态更新接口，请求参数是订单ID和新的状态，返回系统的参数是更新后的订单数据。订单状态更新接口表如表 5-5 所示。

**表 5-5 订单状态更新接口表**

| 接口名称 | 订单状态更新接口 |
|---------|----------------|
| 接口描述 | 管理员或用户更新订单状态 |
| URL | `{{baseurl}}/normal_orders/:id` |
| method | PATCH |
| 请求参数 | status、shipped_time（可选）、completed_time（可选）、updated_at |
| 返回参数 | order：更新后的订单数据 |

订单状态更新核心代码如代码 5-5 所示。

**代码 5-5 订单状态更新实现代码**

```javascript
// 管理员确认出餐
// src/views/admin/orders/orders.vue
const handleConfirmDelivery = async (row) => {
  try {
    await axios.patch(`http://localhost:3001/normal_orders/${row.id}`, {
      status: "已出餐",
      shipped_time: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("订单状态已更新为已出餐");
    await fetchOrders();
  } catch (error) {
    console.error("更新订单状态失败:", error);
    ElMessage.error("更新失败，请稍后重试");
  }
};

// 用户确认取餐
// src/views/order/order.vue
const handleConfirmPickup = async (order) => {
  try {
    await axios.patch(`http://localhost:3001/normal_orders/${order.id}`, {
      status: "已完成",
      completed_time: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("取餐确认成功");
    await fetchOrders();
  } catch (error) {
    console.error("确认取餐失败:", error);
    ElMessage.error("操作失败，请稍后重试");
  }
};
```

---

## 5.3.6 商品评论功能

### （1）功能描述

已完成订单的用户可以对订单中的商品进行评价，包括评分（1-5星）、文字评价、标签选择、图片上传等。评论会显示在商品详情页和用户的个人中心。管理员可以在后台管理评论，包括设置可见性、回复评论、删除评论等。

### （2）实现方案

用户评价：用户在订单列表页面，对于"已完成"状态的订单，点击"去评论"按钮跳转到评价页面。用户填写评价信息后，系统生成有序的评论ID（格式：C001, C002...），通过 `axios.post` 提交评论到 `product_comments` 表。

评论展示：商品详情页通过 `axios.get` 获取该商品的所有可见评论（`is_visible !== false`），按时间倒序展示。个人中心通过 `user_id` 筛选获取用户的所有评论。

管理员管理：管理员在评论管理页面可以查看所有评论，通过 `axios.patch` 更新评论的 `is_visible` 字段控制可见性，通过 `axios.patch` 添加商家回复，通过 `axios.delete` 删除评论。

商品评论的流程如图 5-6 所示。

```
用户完成订单
    ↓
点击"去评论"按钮
    ↓
填写评价信息（评分、内容、标签、图片）
    ↓
生成评论ID（C001, C002...）
    ↓
提交评论 (POST /product_comments)
    ↓
评论显示在商品详情页和个人中心
    ↓
管理员可管理评论（可见性、回复、删除）
```

**图 5-6 商品评论流程图**

针对商品评论接口，请求参数是评论信息，返回系统的参数是创建的评论数据。商品评论接口表如表 5-6 所示。

**表 5-6 商品评论接口表**

| 接口名称 | 商品评论接口 |
|---------|------------|
| 接口描述 | 用户提交商品评价，管理员管理评论 |
| URL | `{{baseurl}}/product_comments` |
| method | GET（查询）、POST（添加）、PATCH（更新）、DELETE（删除） |
| 请求参数 | product_id、user_id、rating、content、tags、images、is_visible（管理员） |
| 返回参数 | comment：id、product_id、user_id、rating、content、tags、images、reply... |

商品评论核心代码如代码 5-6 所示。

**代码 5-6 商品评论实现代码**

```javascript
// 用户提交评论
// src/views/order/components/order-review.vue
import { generateCommentId } from "@/utils/commentIdGenerator";

const submitReview = async () => {
  try {
    for (const product of orderProducts.value) {
      const reviewData = product.reviewData;
      
      if (!reviewData.rating) {
        ElMessage.warning(`请为 ${product.name} 评分`);
        return;
      }

      // 生成有序评论ID
      const commentId = await generateCommentId();

      const commentData = {
        id: commentId,
        product_id: product.id,
        user_id: userStore.userId,
        user_name: userStore.userNickname || userStore.userId,
        avatar: userStore.userAvatar || "",
        content: reviewData.content || "",
        rating: reviewData.rating,
        tags: reviewData.tags || [],
        images: reviewData.images || [],
        useful_count: 0,
        is_visible: true,
        is_audited: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      await axios.post("http://localhost:3001/product_comments", commentData);
    }

    ElMessage.success("评价提交成功");
    router.push("/order");
  } catch (error) {
    console.error("提交评价失败:", error);
    ElMessage.error("提交失败，请稍后重试");
  }
};

// 管理员回复评论
// src/views/admin/comments/comments.vue
const handleReply = async (row) => {
  try {
    await axios.patch(`http://localhost:3001/product_comments/${row.id}`, {
      reply: replyText.value,
      reply_time: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("回复成功");
    replyDialogVisible.value = false;
    await fetchComments();
  } catch (error) {
    console.error("回复失败:", error);
    ElMessage.error("回复失败，请稍后重试");
  }
};
```

---

## 5.3.7 个人中心管理

### （1）功能描述

已登录用户可以在个人中心查看和修改个人信息，包括头像、昵称等。用户可以查看自己的订单统计、购物车商品数量、已发布的评论等信息。

### （2）实现方案

用户信息获取：页面加载时，通过 `userStore.getUserInfo()` 获取当前登录用户的信息，包括昵称、头像等。

头像修改：用户点击头像编辑按钮，可以选择上传本地图片或输入图片URL。如果选择上传，通过 `axios.post` 上传到文件服务器，获取返回的图片路径。然后通过 `axios.patch` 更新用户信息的 `user_info.avatar` 字段。

昵称修改：用户点击昵称编辑按钮，输入新昵称后，通过 `axios.patch` 更新用户信息的 `user_info.nickname` 字段。

个人中心管理的流程如图 5-7 所示。

```
用户进入个人中心
    ↓
获取用户信息 (GET /users/:id)
    ↓
显示用户信息（头像、昵称、订单统计等）
    ↓
用户点击编辑
    ↓
修改头像/昵称
    ↓
上传头像（如需要）(POST /upload/avatar)
    ↓
更新用户信息 (PATCH /users/:id)
    ↓
更新成功，刷新显示
```

**图 5-7 个人中心管理流程图**

针对个人中心管理接口，请求参数是用户信息更新数据，返回系统的参数是更新后的用户数据。个人中心管理接口表如表 5-7 所示。

**表 5-7 个人中心管理接口表**

| 接口名称 | 个人中心管理接口 |
|---------|----------------|
| 接口描述 | 用户查看和修改个人信息 |
| URL | `{{baseurl}}/users/:id` |
| method | GET（查询）、PATCH（更新） |
| 请求参数 | user_info（nickname、avatar）、updated_at |
| 返回参数 | user：更新后的用户数据 |

个人中心管理核心代码如代码 5-7 所示。

**代码 5-7 个人中心管理实现代码**

```javascript
// src/views/profile/profile.vue
const saveAvatar = async () => {
  try {
    if (uploading.value) {
      ElMessage.warning("请等待头像上传完成");
      return;
    }

    let finalAvatarUrl = "";

    // 如果使用URL输入
    if (avatarUrl.value && !uploadedFile.value) {
      finalAvatarUrl = avatarUrl.value;
    }
    // 如果使用上传的文件
    else if (uploadedFile.value) {
      finalAvatarUrl = uploadedFile.value;
    } else {
      ElMessage.warning("请选择头像");
      return;
    }

    // 更新用户信息
    await userStore.updateUserInfo({
      user_info: {
        ...userStore.userInfo.user_info,
        avatar: finalAvatarUrl,
      },
    });

    ElMessage.success("头像更新成功");
    showAvatarDialog.value = false;
    avatarUrl.value = "";
    uploadedFile.value = null;
  } catch (error) {
    console.error("保存头像失败:", error);
    ElMessage.error("保存失败，请稍后重试");
  }
};

const saveNickname = async () => {
  try {
    if (!editingNickname.value.trim()) {
      ElMessage.warning("昵称不能为空");
      return;
    }

    saving.value = true;
    await userStore.updateUserInfo({
      user_info: {
        ...userStore.userInfo.user_info,
        nickname: editingNickname.value.trim(),
      },
    });

    ElMessage.success("昵称更新成功");
    isEditingName.value = false;
  } catch (error) {
    console.error("保存昵称失败:", error);
    ElMessage.error("保存失败，请稍后重试");
  } finally {
    saving.value = false;
  }
};
```

---

## 5.3.8 后台商品管理

### （1）功能描述

管理员可以在后台管理系统中对商品进行增删改查操作，包括添加新商品、编辑商品信息、设置商品价格和折扣、管理库存、上架/下架商品等。

### （2）实现方案

商品列表：管理员进入商品管理页面，通过 `axios.get` 获取所有商品数据，以表格形式展示。支持按商品名称、分类、状态等条件筛选。

添加商品：管理员点击"添加商品"按钮，填写商品表单（名称、价格、库存、描述、图片等），支持设置原价和折扣，系统自动计算当前价格。通过 `axios.post` 提交新商品数据。

编辑商品：管理员点击"编辑"按钮，修改商品信息。支持修改商品描述（可选）、设置折扣功能。通过 `axios.put` 更新商品数据。

删除商品：管理员点击"删除"按钮，通过 `axios.delete` 删除商品。

后台商品管理的流程如图 5-8 所示。

```
管理员进入商品管理页面
    ↓
获取商品列表 (GET /products_list)
    ↓
显示商品列表（支持筛选）
    ↓
添加/编辑/删除商品
    ↓
提交数据 (POST/PUT/DELETE /products_list)
    ↓
更新成功，刷新列表
```

**图 5-8 后台商品管理流程图**

针对后台商品管理接口，请求参数是商品信息，返回系统的参数是商品数据。后台商品管理接口表如表 5-8 所示。

**表 5-8 后台商品管理接口表**

| 接口名称 | 后台商品管理接口 |
|---------|----------------|
| 接口描述 | 管理员对商品进行增删改查操作 |
| URL | `{{baseurl}}/products_list` |
| method | GET（查询）、POST（添加）、PUT（更新）、DELETE（删除） |
| 请求参数 | title、price_info、stock、description、category、status、hasDiscount、discount... |
| 返回参数 | product：商品数据 |

后台商品管理核心代码如代码 5-8 所示。

**代码 5-8 后台商品管理实现代码**

```javascript
// src/views/admin/products/components/ProductForm.vue
const submitForm = async () => {
  try {
    await formRef.value.validate();

    const submitData = {
      ...form.value,
      price_info: {
        original_price: form.value.price_info.original_price,
        current_price: form.value.hasDiscount 
          ? discountedPrice.value 
          : form.value.price_info.original_price,
        hasDiscount: form.value.hasDiscount,
        discount: form.value.hasDiscount ? form.value.price_info.discount : 0,
      },
      status: form.value.status || "1",
      updated_at: new Date().toISOString(),
    };

    if (props.productId) {
      // 更新商品
      await axios.put(
        `http://localhost:3001/products_list/${props.productId}`,
        submitData
      );
      ElMessage.success("商品更新成功");
    } else {
      // 添加商品
      submitData.created_at = new Date().toISOString();
      await axios.post("http://localhost:3001/products_list", submitData);
      ElMessage.success("商品添加成功");
    }

    emit("success");
  } catch (error) {
    console.error("提交失败:", error);
    ElMessage.error("操作失败，请稍后重试");
  }
};

// 计算折扣价格
const discountedPrice = computed(() => {
  if (!form.value.hasDiscount) {
    return form.value.price_info.original_price;
  }
  const originalPrice = form.value.price_info.original_price || 0;
  const discount = form.value.price_info.discount || 0;
  return originalPrice * (1 - discount / 100);
});
```

---

## 5.3.9 后台订单管理

### （1）功能描述

管理员可以在后台查看所有用户的订单，按订单状态、用户ID等条件筛选，查看订单详情，更新订单状态（如确认出餐），与用户进行订单沟通。

### （2）实现方案

订单列表：管理员进入订单管理页面，通过 `axios.get` 获取所有订单数据，以表格形式展示。支持按订单状态、用户ID、订单号等条件筛选和搜索。

订单详情：管理员点击"查看详情"按钮，弹窗显示订单的完整信息，包括商品列表、总价、取餐信息、订单状态、沟通记录等。

状态更新：管理员点击"确认出餐"按钮，通过 `axios.patch` 更新订单状态为"已出餐"，同时记录 `shipped_time`。

后台订单管理的流程如图 5-9 所示。

```
管理员进入订单管理页面
    ↓
获取订单列表 (GET /normal_orders)
    ↓
显示订单列表（支持筛选）
    ↓
查看订单详情/更新订单状态
    ↓
提交更新 (PATCH /normal_orders/:id)
    ↓
更新成功，刷新列表
```

**图 5-9 后台订单管理流程图**

针对后台订单管理接口，请求参数是订单ID和更新数据，返回系统的参数是更新后的订单数据。后台订单管理接口表如表 5-9 所示。

**表 5-9 后台订单管理接口表**

| 接口名称 | 后台订单管理接口 |
|---------|----------------|
| 接口描述 | 管理员查看和管理订单 |
| URL | `{{baseurl}}/normal_orders` |
| method | GET（查询）、PATCH（更新） |
| 请求参数 | id、status、shipped_time、updated_at |
| 返回参数 | order：订单数据 |

后台订单管理核心代码如代码 5-9 所示。

**代码 5-9 后台订单管理实现代码**

```javascript
// src/views/admin/orders/orders.vue
const fetchOrders = async () => {
  loading.value = true;
  try {
    const response = await axios.get("http://localhost:3001/normal_orders");
    allOrders.value = response.data.map(order => ({
      ...order,
      userId: order.user_id || "未知",
    }));
  } catch (error) {
    console.error("获取订单失败:", error);
    ElMessage.error("获取订单失败");
  } finally {
    loading.value = false;
  }
};

const handleConfirmDelivery = async (row) => {
  try {
    await axios.patch(`http://localhost:3001/normal_orders/${row.id}`, {
      status: "已出餐",
      shipped_time: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    });

    ElMessage.success("订单状态已更新为已出餐");
    await fetchOrders();
  } catch (error) {
    console.error("更新订单状态失败:", error);
    ElMessage.error("更新失败，请稍后重试");
  }
};
```

---

## 5.3.10 后台用户管理

### （1）功能描述

管理员可以在后台查看所有用户信息，包括用户ID、登录账号、昵称、角色、账户状态等，支持编辑用户信息、禁用/启用用户账户。

### （2）实现方案

用户列表：管理员进入用户管理页面，通过 `axios.get` 获取所有用户数据，以表格形式展示。显示用户统计信息（总用户数、管理员数、普通用户数、禁用用户数）。

用户编辑：管理员点击"编辑"按钮，修改用户信息（昵称、邮箱、电话、账户状态等），通过 `axios.put` 更新用户数据。

用户添加：管理员点击"添加用户"按钮，填写用户表单，系统自动生成短ID（格式：user + 6位时间戳 + 随机后缀），通过 `axios.post` 添加新用户。

后台用户管理的流程如图 5-10 所示。

```
管理员进入用户管理页面
    ↓
获取用户列表 (GET /users)
    ↓
显示用户列表和统计信息
    ↓
添加/编辑用户
    ↓
提交数据 (POST/PUT /users)
    ↓
更新成功，刷新列表
```

**图 5-10 后台用户管理流程图**

针对后台用户管理接口，请求参数是用户信息，返回系统的参数是用户数据。后台用户管理接口表如表 5-10 所示。

**表 5-10 后台用户管理接口表**

| 接口名称 | 后台用户管理接口 |
|---------|----------------|
| 接口描述 | 管理员对用户进行增删改查操作 |
| URL | `{{baseurl}}/users` |
| method | GET（查询）、POST（添加）、PUT（更新）、DELETE（删除） |
| 请求参数 | id、username、password、role、email、phone、user_info、account_status... |
| 返回参数 | user：用户数据 |

后台用户管理核心代码如代码 5-10 所示。

**代码 5-10 后台用户管理实现代码**

```javascript
// src/views/admin/users/users.vue
const fetchUsers = async () => {
  loading.value = true;
  try {
    const response = await axios.get("http://localhost:3001/users");
    allUsers.value = response.data;
    
    // 计算统计信息
    stats.value = {
      total: allUsers.value.length,
      admins: allUsers.value.filter(u => u.role === "admin").length,
      users: allUsers.value.filter(u => u.role === "user").length,
      disabled: allUsers.value.filter(u => u.account_status === "inactive" || u.account_status === "banned").length,
    };
  } catch (error) {
    console.error("获取用户失败:", error);
    ElMessage.error("获取用户失败");
  } finally {
    loading.value = false;
  }
};

const generateUserId = () => {
  const timestamp = Date.now().toString();
  const randomSuffix = Math.random().toString(36).substr(2, 3);
  let userId = `user${timestamp.slice(-6)}${randomSuffix}`;
  
  // 检查ID是否已存在
  while (allUsers.value.some(u => u.id === userId)) {
    const newTimestamp = Date.now().toString();
    const newRandomSuffix = Math.random().toString(36).substr(2, 3);
    userId = `user${newTimestamp.slice(-6)}${newRandomSuffix}`;
  }
  
  return userId;
};

const handleSubmit = async () => {
  try {
    await formRef.value.validate();

    const userData = {
      ...form.value,
      user_info: {
        nickname: form.value.nickname || "",
        avatar: form.value.avatar || "",
      },
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    if (props.userId) {
      // 更新用户
      await axios.put(`http://localhost:3001/users/${props.userId}`, userData);
      ElMessage.success("用户更新成功");
    } else {
      // 添加用户
      userData.id = generateUserId();
      await axios.post("http://localhost:3001/users", userData);
      ElMessage.success("用户添加成功");
    }

    emit("success");
  } catch (error) {
    console.error("提交失败:", error);
    ElMessage.error("操作失败，请稍后重试");
  }
};
```

---

**文档版本**: v1.0  
**最后更新**: 2025-12-28  
**维护人员**: 开发团队


